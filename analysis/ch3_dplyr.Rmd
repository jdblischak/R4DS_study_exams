---
title: "Chapter 3 - Data Transformation with dplyr"
author: "Vebash Naidoo"
date: "17/09/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

```{r}
library(tidyverse)
library(flair)
library(nycflights13)
library(palmerpenguins)
library(gt)
library(skimr)
library(emo)
library(tidyquant)
library(lubridate)
library(magrittr)
theme_set(theme_tq())
```


## Filter rows

<span style="color: #008080;background-color:#9FDDBA">`filter()`</span> 
is the verb used to subset rows in a dataframe
based on their values - i.e. we take a dataset and we say _hey, give me back data that looks like it fulfils this condition(s)_.

The `nycflights13` package has flights for the year 2013 where the departure was from an airport in New York City. You will notice the `%>%` which we used
in the `ggplot` chapter too. If you can't recall what it does for now ignore it and just have a look at the data contained in the dataset.

Aside: the pipe into gt() is to print out a neat table `r emo::ji("smile")`.

```{r}
flights %>% 
  head(4) %>% 
  gt()

```
<br>

```{r}
flights %>% 
  count(origin, sort=TRUE) %>% 
  gt()
```

<br>

Let's filter all flights that occurred on Jan 1. The syntax for filter is <span style="color: #008080;background-color:#9FDDBA">`filter(df, some_condition_s)`</span> 

```{r filter1, include=FALSE}
filter(flights, month == 1, day == 1)
```

```{r, echo = FALSE}
decorate("filter1") %>% 
  flair("filter", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("==", background = "#9FDDBA", 
        color = "#008080")
```

<em>Notice the <span style="color: #008080;background-color:#9FDDBA">`==`</span> for comparison</em>

```{r, echo=FALSE}
comparison_ops <- tibble::tribble(
  ~sign,                   ~meaning,
    ">",             "greater than",
   ">=", "greater than or equal to",
    "<",                "less than",
   "<=",    "less than or equal to",
   "==",                 "equal to",
   "!=",             "not equal to"
  )

comparison_ops %>% gt()
```
<br>

Okay, truly the `{palmerpenguins}` data is going to become the new `iris`! But
come on' who doesn't love penguins! Just try and keep me away from
Boulders Beach in Cape Town when I'm there visiting ...

```{r}
penguins %>% 
  head(10) %>% 
  gt()

```

<br>

Ok, what types of penguins are there?

```{r}
penguins %>% 
  count(species, sort=TRUE)
```

Let's filter out `Gentoo` with `bill_depth_mm` bigger than 17mm, using some of the operations we learnt.

```{r filter2, include=FALSE}
# lets us save the filter result and 
# prints it out ... the extra brackets on the
# outside of the entire code block does that
(gentoo <- filter(penguins, species == 'Gentoo',
       bill_depth_mm > 17))

```

```{r, echo = FALSE}
decorate("filter2") %>% 
  flair("filter", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("==", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair(">", background = "#9FDDBA", 
        color = "#008080")
```

__Surprising results__

Floats are saved a bit differently and hence can cause some unexpected behaviour.

```{r}
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1
```

Use `near()` to give you if these are indeed nearly same.

```{r near, include=FALSE}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

```{r, echo = FALSE}
decorate("near") %>% 
  flair("near", background = "#9FDDBA", 
        color = "#008080")
```

### Logic

When we explore data we often want to filter data where one condition is true and another is also true. E.g. Which days experienced a thunder storm where a thunder storm was predicted by the Meteorologists.

In R we use logic operators to combine comparisons and get us the data we're looking for.

<br>

```{r, echo=FALSE}
log_ops <- tibble::tribble(
  ~sign, ~meaning,
    "|",     "Or",
    "&",    "And",
    "!",    "Not"
  )
log_ops %>% gt()
```

<br>

Let's say we want only flights that occurred in Nov and Dec of 2013:

```{r good_filter, include=FALSE}
filter(flights, month == 11 | month == 12)
```

```{r, echo=FALSE}
decorate("good_filter") %>% 
  flair("month == 11 | month == 12", background = "#9FDDBA", 
        color = "#008080")
```

We have to repeat the <span style="color: #008080;background-color:#9FDDBA">month == </span> part for each comparison.

<br>

You may think that you can just say <span style="color: #FFE4E1;background-color:#E3242B">month == (11 | 12)</span> but unfortunately that does not
work. 

```{r bad_filter, eval=FALSE, include=FALSE}
(filtered_fl <- filter(flights, month == (11 | 12)))
```

```{r, echo=FALSE}
decorate("bad_filter") %>% 
  flair('month == (11 | 12)',
        background = "#E3242B", 
        color = "#FFE4E1")
```
<br>Note that the result is unexpected - the tibble returned contains the `month == 1` which is January, and should not be in our returned dataset! The `(11 | 12)` evaluates to `r (11 | 12)` which internally is represented as `1` hence we then look at `month == 1`.
To see this lets load the flights dataframe and filter Jan again. Notice that the number of rows is identical to the number of rows in the filtered `filtered_fl` which is `r nrow(filtered_fl)`.


```{r}
flights %>% 
  filter(month == 1)
```
<br>

We can also use the <span style="color: #008080;background-color:#9FDDBA">`%in%`</span>  operator instead of repeating the `month ==`.

```{r}
filter(flights, month %in% c(11, 12))
```
If you need the opposite of this i.e. the `not in` operator it's a bit more tricky.

You can make your own function for [this](https://stackoverflow.com/questions/5831794/opposite-of-in-exclude-rows-with-values-specified-in-a-vector).

```{r}
'%!in%' <- function(x,y)!('%in%'(x,y)) # method 1
'%ni%' <- Negate('%in%') # method 2
filter(flights, month %ni% c(11, 12))
```

#### Aside: Some penguin fun ...

Let's see if we can explore our data through filtering.

```{r}
# Get all penguins where the species is anything
# other than Adelie
filter(penguins, species %ni% ('Adelie'))
```

The skim function also works great in conjunction
with filter. I am going to use the pipe again which
we tackle later in R4DS. For now when you see _%>%_ read it as `and then` e.g. _Take this df and then filter out data that meets the condition and then show me a summary._

<pre>
    df <span style="color: #008080;background-color:#9FDDBA">%>%</span> 
      filter(some_col meets some condition) <span style="color: #008080;background-color:#9FDDBA">%>%</span> 
      summary(avg_col = mean(some_col))
</pre>

```{r}
penguins %>% 
  filter(species == "Chinstrap") %>% 
  skim()
```

Let's see if the Chinstrap penguins with a body mass above the mean are more likely male / female / equally represented?

The pipe way:

```{r}
penguins %>% 
  filter(species == "Chinstrap") %>% 
  filter(body_mass_g > mean(body_mass_g)) %>% 
  skim()
```

We get the same using the non-piped way.

```{r}
skim(filter(filter(penguins, species == "Chinstrap"),
       body_mass_g > mean(body_mass_g))) 
```

It seems there are more male penguins above the mean of body mass.


### Exercises

1.  Find all flights that

    - Had an arrival delay of two or more hours
        
    ```{r filt_ex1, include = FALSE}
    filter(flights,
           arr_delay >= 120)
    
    ```
    
    ```{r, echo=FALSE}
    decorate("filt_ex1") %>% 
      flair('arr_delay >= 120',
            background = "#9FDDBA", 
            color = "#008080")
    ```
    
    
    - Flew to Houston (`IAH` or `HOU`)
    
    ```{r}
    filter(flights, dest %in% c('IAH', 'HOU'))
    ```
    
    
    - Were operated by United, American, or Delta
    ```{r}
    as_tibble(flights) %>% 
      distinct(carrier) %>% 
      arrange(carrier)
    
    # think these are United = UA, American = AA, Delta = DL
    filter(flights, carrier %in% c('UA', 'AA', 'DL'))
    ```
    
    - Departed in summer (July, August, and September)
    ```{r}
    filter(flights, month %in% c(7, 8, 9))
    ```
    
    - Arrived more than two hours late, but didn't leave late
    ```{r}
    filter(flights,
           arr_delay > 120 & dep_delay <= 0)
    
    ```
    
    - Were delayed by at least an hour, but made up over 30 minutes in flight
    ```{r}
    filter(flights, 
           dep_delay >= 60 &
           arr_delay < (dep_delay - 30))
    ```
    
    - Departed between midnight and 6am (inclusive)
    ```{r}
    flights %>% # notice that some flights were schedule to leave befor 00h00 but 
      # were delayed and hence left after 00h00
      filter(dep_time > 0 & dep_time < 100)
    
    flights %>% 
      # are any flights exactly at 24h00?
      filter(dep_time == 2400)
    
    filter(flights, (dep_time >= 0 & dep_time <= 600) | 
             (dep_time == 2400))
    

    ```
        

1.  Another useful dplyr filtering helper is `between()`. What does it do?
    Can you use it to simplify the code needed to answer the previous 
    challenges?
    
    ```{r}
    # Departed in summer (July, August, and September)
    filter(flights, between(month,7,9))
    # Departed between midnight and 6am (inclusive)
    filter(flights, between(dep_time, 0, 600) | 
         (dep_time == 2400))
    ```
    
1.  How many flights have a missing `dep_time`? What other variables are 
    missing? What might these rows represent?
    ```{r}
    filter(flights, is.na(dep_time))
    
    skim(flights) # Great summary function from skimr
    ```
    

1.  Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing?
    Why is `FALSE & NA` not missing? Can you figure out the general
    rule?  (`NA * 0` is a tricky counterexample!)
    
    ```{r}
    # Anything to the power 0, is 1
    NA ^ 0
    
    # Anything OR TRUE, is still TRUE
    NA | TRUE
    
    # FALSE and anything, is FALSE
    FALSE & NA
    
    # Not everything * 0 is 0; e.g sqrt(-2) * 0 is NaN
    NA * 0
    
    ```

Check out [Suzan Baert's](https://twitter.com/SuzanBaert) great `dplyr` tutorial on [filter](https://suzan.rbind.io/2018/02/dplyr-tutorial-3/)

## Arrange

<span style="color: #008080;background-color:#9FDDBA">`arrange()`</span>  changes the order of the observations based on the columns you provide and the order you want it arranged. The syntax is `arrange(df, cols_to_order_by)` E.g. `arrange(df, col1, col2)` says "Hey, take this df and arrange the observations in alphabetical/increasing numeric order of col1 and col2." col2 comes in when there are ties in col1.

We use desc() or `-` when we want to order the observations in reverse for a column.

```{r arr1, include = FALSE}
arrange(flights, desc(arr_delay), 
        desc(dep_delay),
        day, month, year) %>% 
  head(10) %>% 
  gt()
```

```{r, echo=FALSE}
decorate("arr1") %>% 
  flair("desc", background = "#9FDDBA", 
        color = "#008080")
```

<br>

Using the `-` sign instead of `desc()` yields the same results.

```{r arr2, include = FALSE}
arrange(flights, -arr_delay, 
        -dep_delay,
        day, month, year) %>% 
  head(10) %>% 
  gt()
```

```{r, echo=FALSE}
decorate("arr2") %>% 
  flair("-", background = "#9FDDBA", 
        color = "#008080")
```
<br>

### Exercises

1.  How could you use `arrange()` to sort all missing values to the start? Answer found [here](https://stackoverflow.com/questions/37760580/dplyr-arrange-function-sort-by-missing-values).
    (Hint: use `is.na()`).
    
    ```{r}
    flights %>% 
      # arrange by highest row sum of NA's
      # observations with most NAs float to the
      # top of the df returned
      arrange(desc(rowSums(is.na(.))))
    ```
    
    
1.  Sort `flights` to find the most delayed flights. Find the flights that
    left earliest.
    ```{r}
    arrange(flights, -dep_delay,
            dep_time)
    ```
    

1.  Sort `flights` to find the fastest (highest speed) flights.

    ```{r}
    arrange(flights, desc(distance/air_time))
    
    ```


1.  Which flights travelled the farthest? Which travelled the shortest?

- farthest
```{r}
# farthest
arrange(flights, desc(distance))
```

- shortest (assuming shortest distance here in context above)
```{r}
arrange(flights, distance)
```


## Select columns

<span style="color: #008080;background-color:#9FDDBA">`select()`</span>
allows you to choose a subset of <span style="color: #008080;background-color:#9FDDBA">columns / variables</span> in your data.

Let's try out some using the `penguins` data.

```{r}
as_tibble(names(penguins_raw) ) %>% 
  gt() %>% 
  tab_options(
    heading.title.font.size = "small",
    table.font.size = "small"
  )
```

<br>

- Select columns by <span style="color: #008080;background-color:#9FDDBA">name</span>

```{r by_name, include=FALSE}
select(penguins_raw, "Sample Number",
       Island, Sex)
```


```{r, echo=FALSE}
decorate("by_name") %>% 
  flair('"Sample Number"', background = "#9FDDBA", 
        color = "#008080") %>% 
  flair('Island, Sex', background = "#9FDDBA", 
        color = "#008080")  
```

- Select columns in a <span style="color: #008080;background-color:#9FDDBA">range</span>

```{r range, include=FALSE}
select(penguins_raw, 
       "Sample Number":"Individual ID")
```


```{r, echo=FALSE}
decorate("range") %>% 
  flair(':', background = "#9FDDBA", 
        color = "#008080")
```

- Select everything <span style="color: #008080;background-color:#9FDDBA">except for</span>

```{r exceptions, include=FALSE}
select(penguins_raw, -Comments, 
       -(Region:"Date Egg"),
       -ends_with("(o/oo)"))
```

```{r, echo=FALSE}
decorate("exceptions") %>% 
  flair('-', background = "#9FDDBA", 
        color = "#008080")
```

- Select using helper functions (we saw one above)

    * <span style="color: #008080;background-color:#9FDDBA">`starts_with("abc")`</span> : matches names that begin with "abc".
    
    * <span style="color: #008080;background-color:#9FDDBA">`ends_with("xyz")`</span>: matches names that end with "xyz".
    
    * <span style="color: #008080;background-color:#9FDDBA">`contains("ijk")`</span>: matches names that contain "ijk".
    
    * <span style="color: #008080;background-color:#9FDDBA">`matches("(.)\\1")`</span>: selects variables that match a regular expression.
       This one matches any variables that contain repeated characters. You'll 
       learn more about regular expressions in [strings].
       
    *  <span style="color: #008080;background-color:#9FDDBA">`num_range("x", 1:3)`</span>: matches `x1`, `x2` and `x3`.
    
```{r sel_helpers, include=FALSE}
select(penguins_raw, 
       # cols starting with "Delta"
       starts_with("Delta")) 

select(penguins_raw, 
       # all cols except those ending with "(o/oo)"
       -ends_with("(o/oo)"))

select(penguins_raw, 
       # all columns except those with mm
       -contains("(mm)"))

select(penguins_raw, 
       # any cols having brackets 
       # with letters  or / inside
       matches("\\([a-zA-Z/]+\\)"))
```


```{r, echo=FALSE}
decorate("sel_helpers") %>% 
  flair("starts_with", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("ends_with", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("contains", background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("matches", background = "#9FDDBA", 
        color = "#008080")
```

- Use `select()` to <span style="color: #008080;background-color:#9FDDBA">reorder columns</span>.

```{r every, include=FALSE}
# move Species, Region, Island upfront them put
# in the rest
select(penguins_raw, Species, Region, Island,
       everything())

```

```{r, echo=FALSE}
decorate("every") %>% 
  flair("everything()", background = "#9FDDBA", 
        color = "#008080") 

```

### Exercises

1.  Brainstorm as many ways as possible to select `dep_time`, `dep_delay`,
    `arr_time`, and `arr_delay` from `flights`.
    
    ```{r}
    # by name
    select(flights, dep_time, dep_delay,
           arr_time, arr_delay)
    # range
    select(flights, dep_time:arr_delay,
           -sched_dep_time,
           -sched_arr_time)
    
    # except for
    select(flights, -(year:day),
           -sched_dep_time,
           -sched_arr_time,
           -(carrier:time_hour))
    
    # starts with
    select(flights, 
           starts_with("dep"),
           starts_with("arr"))
    
    # ends with
    select(flights, 
           ends_with("time"),
           ends_with("delay"),
           -sched_dep_time,
           -sched_arr_time,
           -air_time)
    
    # contains
    select(flights, 
           contains("dep_"),
           contains("arr_"), 
           -sched_dep_time,
           -sched_arr_time)
    
    # matches
    select(flights, 
           matches("^(dep|arr)_(delay|time)"))
    ```
    
    
1.  What happens if you include the name of a variable multiple times in
    a `select()` call?
    
    Only one instance is included. 
    If you want both variables you have to
    rename both variables.
    
    ```{r select_1, include=FALSE}
    select(penguins, species, island,
           ends_with("mm"),
           species,
           body_mass_g:year)

    select(penguins, species = species, island,
           ends_with("mm"),
           rep_species = species,
           body_mass_g:year)        
    ```
    
    ```{r, echo=FALSE}
    decorate("select_1") %>% 
      flair("species = species", 
            background = "#9FDDBA", 
            color = "#008080") %>% 
      flair("rep_", 
            background = "#9FDDBA", 
            color = "#008080") 
    ```  
1.  What does the `one_of()` function do? Why might it be helpful in conjunction
    with this vector?
    
    ```{r}
    vars <- c("year", "month", "day", "dep_delay", "arr_delay")
    ```
    It selects a column if it forms a part of
    the vector.
    
    ```{r}
    select(flights,
           one_of(vars))
    ```
    
    
1.  Does the result of running the following code surprise you?  How do the
    select helpers deal with case by default? How can you change that default?

    ```{r, eval = FALSE}
    select(flights, contains("TIME"))
    ```    
    
    The default is `ignore.case = TRUE` hence 
    this behaviour. If you want to find the precise
    thing you're looking for add 
    <span style="color: #008080;background-color:#9FDDBA">`ignore.case = FALSE`</span>
     in your helper function.


    
    ```{r}
    select(flights, contains("TIME"))
    ```
    
    ```{r ignore, include = FALSE}
    select(flights, 
           contains("TIME", 
                    ignore.case = FALSE))
    ```
    
    ```{r, echo=FALSE}
    decorate("ignore") %>% 
      flair("ignore.case = FALSE", 
            background = "#9FDDBA", 
            color = "#008080") 
    ```
    

## Mutate  

<span style="color: #008080;background-color:#9FDDBA">`mutate()`</span> 
is the verb used to create new variables in your dataframe based on other variables in your dataset.

```{r mut1, include=FALSE}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```


```{r, echo=FALSE}
decorate("mut1") %>% 
  flair("mutate", background = "#9FDDBA", 
        color = "#008080")
```

To keep the new variables only, use <span style="color: #008080;background-color:#9FDDBA">`transmute()`</span>.

```{r tm, include=FALSE}
transmute(flights,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

```{r, echo=FALSE}
decorate("tm") %>% 
  flair("transmute", background = "#9FDDBA", 
        color = "#008080")
```

There are many operations you can use inside `mutate()` and `transmute()`, the key is that the function is vectorisable.

Modular arithmetic: `%/%` (integer division) and `%%` (remainder) are handy tools because 
it allows you to break integers up into pieces. For example we can compute `hour` and `minute` from `dep_time` using:

```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

### Exercises

```{r, eval = FALSE, echo = FALSE}
flights <- flights %>% mutate(
  dep_time = hour * 60 + minute,
  arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
  airtime2 = arr_time - dep_time,
  dep_sched = dep_time + dep_delay
)
ggplot(flights, aes(dep_sched)) + geom_histogram(binwidth = 60)
ggplot(flights, aes(dep_sched %% 60)) + geom_histogram(binwidth = 1)
ggplot(flights, aes(air_time - airtime2)) + geom_histogram()
```

1.  Currently `dep_time` and `sched_dep_time` are convenient to look at, but
    hard to compute with because they're not really continuous numbers. 
    Convert them to a more convenient representation of number of minutes
    since midnight.
    
    ```{r mut_ex1, include=FALSE}
    flights %>% 
      select(dep_time, 
                       sched_dep_time, time_hour)
    
    mutate(flights,
           minutes_since_00 = 
             # get int hr and mult by 60 to 
             # get hours converted to minutes.
             (dep_time %/% 100) * 60 + 
             (dep_time %% 100)) # add minutes
    
    flights %>% 
      select(dep_time, 
             sched_dep_time, time_hour) %>% 
      filter(dep_time == 2400 | dep_time == 0) %>% 
      mutate(minutes_since_00 = 
             # get int hr and mult by 60 to 
             # get hours converted to minutes.
             (dep_time %/% 100) * 60 + 
             (dep_time %% 100)) # add minutes
    ```
    
    ```{r, echo=FALSE}
    decorate("mut_ex1") %>% 
      flair("mutate", background = "#9FDDBA", 
            color = "#008080") %>% 
      flair("minutes_since_00 = ", 
            background = "#9FDDBA", 
            color = "#008080")
    ```    
    We see that the flights have midnight flights 
    as 2400 and there's none that are marked as 0.
    So we can change all 2400 to 0. We will learn 
    the `if_else()` construct later on, for now 
    it follows the syntax 
    
    <pre>
      if_else(condition,
              do_this_if_condition_met_true,
              do_this_otherwise)
    </pre>              

    ```{r mut_ex2, include=FALSE}
    flights_mut2 <- mutate(flights, 
           # if dep_time == 2400 (i.e. midnights)
           # convert it to 0, else we keep the orig
           # dep_time
           dep_time = if_else(dep_time == 2400, 
                              as.integer(0),
                              as.integer(dep_time)),
           sched_dep_time = 
             if_else(sched_dep_time == 2400,
                      as.integer(0),
                      as.integer(sched_dep_time)),
           minutes_dep_time = 
             (dep_time %/% 100) * 60 + 
             (dep_time %% 100),
           minutes_sched_dep_time = 
             (sched_dep_time %/% 100) * 60 + 
             (sched_dep_time %% 100))
    
    flights_mut2 %>% 
      select(dep_time, sched_dep_time,
             minutes_dep_time,
             minutes_sched_dep_time) %>% 
      head(10)
    
    flights_mut2 %>% 
      select(dep_time, sched_dep_time,
             minutes_dep_time,
             minutes_sched_dep_time) %>% 
      filter(dep_time == 0 | 
               sched_dep_time == 0) %>% 
      head(10)      
    ```
    
    ```{r, echo=FALSE}
    decorate("mut_ex2") %>% 
      flair("if_else", background = "#9FDDBA", 
            color = "#008080") %>% 
      flair("minutes_dep_time = ", 
            background = "#9FDDBA", 
            color = "#008080") %>% 
      flair("minutes_sched_dep_time = ", 
            background = "#9FDDBA", 
            color = "#008080")
    ```       
    
    
1.  Compare `air_time` with `arr_time - dep_time`. What do you expect to see?
    What do you see? What do you need to do to fix it?
    
    ```{r}
    flights %>% 
      select(air_time,
             arr_time,
             dep_time) %>% 
      mutate(diff_time = arr_time - dep_time)
    
    ```
    We see that just taking the difference 
    between these times is misleading. Maybe we need
    to do the same as before, convert these to
    minutes since midnight before taking the
    difference? `r emo::ji("shrug")`
    
    ```{r}
    flights_mut2 <- mutate(flights_mut2,
                           arr_time = 
                             if_else(arr_time == 2400, 
                                  as.integer(0),
                                  as.integer(arr_time)),
                     minutes_arr_time = 
                       (arr_time %/% 100) * 60 + 
                       (arr_time %% 100),
                     diff_time = 
                       minutes_arr_time - 
                       minutes_dep_time,
                     diff_in_metrics =
                       air_time - diff_time
                     )
  flights_mut2 %>% 
      select(origin,
             dest, 
             air_time,
             arr_time,
             dep_time,
             minutes_arr_time,
             minutes_dep_time,
             diff_time, 
             diff_in_metrics) %>% 
      head(10) %>% 
      gt()

    ```
    <br>
    
    Not quite, we see. So what else could be 
    the difference? It could be that the arrival
    time is the local time at the destination. For
    example the time difference between New York and
    Houston is 1 hour. Houston is 1 hour behind New
    York. But upon checking the first couple some
    airports share the same timezone so I am a 
    bit perplexed to tell the truth. E.g. the 3rd
    entry and the 4th entry, upon googling, suggests
    these are the same timezones? 
    `r emo::ji("confused")`
    
1.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you
    expect those three numbers to be related?
    
    I would expect that: 
    
    > dep_delay = dep_time - sched_dep_time
    
    ```{r}
    flights_mut3 <- mutate(flights_mut2,
           dep_delay_test = minutes_dep_time - 
             minutes_sched_dep_time) %>% 
      select(dep_time,
             sched_dep_time,
             minutes_dep_time,
             minutes_sched_dep_time,
             dep_delay, dep_delay_test)
    
    flights_mut3
    
    flights_mut3 %>% 
      filter(dep_delay != dep_delay_test)
    ```
    
    This does seem to be the case for most flights
    except for flights that were delayed overnight.
    To cater for these we'd need to work out 
    whether the flight departed on the same day.
    If they departed on different days we would find
    how many minutes left to midnight, and then subtract the 
    scheduled dep time from this and add to the
    departure time to get the delay.
    
    ```{r}
    
    flights_mut2 %>% 
      filter(dep_delay < 0) %>% 
      arrange((dep_delay)) %>% 
      head(4) %>% 
      gt()
    
    flights_mut3 <- mutate(flights_mut2,
               dep_delay_test = 
                 if_else(
                   (minutes_dep_time >=
                    minutes_sched_dep_time) |
                   (minutes_dep_time -
                     minutes_sched_dep_time ) > -45,
                 minutes_dep_time - 
                  minutes_sched_dep_time,
                 24*60 - minutes_sched_dep_time +
                   minutes_dep_time)) %>% 
          select(dep_time,
                 sched_dep_time,
                 minutes_dep_time,
                 minutes_sched_dep_time,
                 dep_delay, dep_delay_test)
          
    flights_mut3
        
    flights_mut3 %>% 
        filter(dep_delay != dep_delay_test) %>% 
      head(10) %>% 
      gt()
    
    ```
    <br>
    The above checks the biggest difference for those
    flights that had dep_delay < 0. _Note: This is a bit
    hacky. Best approach is to compare dates but 
    both the year-month-day and time_hour reflect the
    same date._

    
1.  Find the 10 most delayed flights using a ranking function. How do you want 
    to handle ties? Carefully read the documentation for `min_rank()`.
    
    ```{r}
    
    mutate(flights,
           rank = min_rank(desc(dep_delay))) %>% 
      arrange(rank) %>% 
      head(10) %>% 
      gt()
    
    
    ```
    <br>
    
1.  What does `1:3 + 1:10` return? Why?
    
    ```{r}
    1:3 + 1:10
    ```
    
    The vector that is shorter gets recycled.
    
    So essentially it is outputting:
    
    ```{r}
    df <- data.frame(a = c(rep(1:3,3), 1),
                     b = 1:10)
    df %>% 
      mutate(c = a + b) %>% 
      gt()
    ```

1.  What trigonometric functions does R provide?
    
    It provides pretty much all the trig functions. [Here](
    https://stat.ethz.ch/R-manual/R-devel/library/base/html/Trig.html
    ) is a list.
  
## Grouped summaries with `summarise()`/`summarize()`

If you need to find out the maximum of a certain variable, or the mean, median, minimum etc. you use `summarise()`. `na.rm = TRUE` means exclude the NA values then get the summary stat. I added a simple example in the code below.
Notice that when we have NAs in our dataset and then we take a mean, the result is NA. If there are NAs in the input, there are NAs in the output. The `na.rm = TRUE`
helps us by ignoring the NA values, and getting the summary stat for the non NA values here.

```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))

summarise(flights,
          n = n(),
          biggest_dep_delay = max(dep_delay, na.rm = TRUE),
          biggest_arr_delay = max(arr_delay, na.rm = TRUE))

# Why use na.rm?
test = c(3, 3, 6, 6, NA, NA)
mean(test)
mean(test, na.rm = TRUE)
```

Did you see that when we used `mean(test, na.rm = TRUE)` we got a result of 4.5, 
which is $(3 + 3+ 6 + 6)/4$. I.e. the NA values are removed and the count that
forms the denominator is also updated.

Summary stats are most often valuable when we look across groups. For example,
let's say we wanted to know the median bill length of penguins based on species and sex. We first group by species and sex since we're interested to see how the
stats change based on species and whether the penguin is male/female. When I ran it the first time there were some species that had sex == NA, so I removed the NA values from the penguin dataset before grouping it.

```{r peng_sum1, include=FALSE}

by_species_sex <- group_by(drop_na(penguins), species, sex)
summarise(by_species_sex,
          med_bill_length_mm = median(bill_length_mm, na.rm = TRUE),
          med_bill_depth_mm = median(bill_depth_mm, na.rm = TRUE),
          med_flipper_length_mm = median(flipper_length_mm, na.rm = TRUE),
          med_body_mass_g = median(body_mass_g, na.rm = TRUE)) %>% 
gt()

```

```{r, echo=FALSE}
decorate("peng_sum1") %>% 
    flair("group_by", background = "#9FDDBA", 
        color = "#008080") %>% 
    flair(" species", background = "#9FDDBA", 
        color = "#008080") %>% 
    flair(" sex", background = "#9FDDBA", 
        color = "#008080") %>% 
    flair("summarise", background = "#9FDDBA", 
        color = "#008080") %>% 
    flair("median", background = "#9FDDBA", 
        color = "#008080")
```

## The pipe: %>%

The book uses an example with flights, here we add a new example with the
penguins data set. As pointed out in the book, it is a bit tedious,
and arguably doesn't flow very well, or read particularly well the first way.

Hence the pipe! The pipe is more inuitive for me, and as discussed previously
can be read as _as then_.

### More onerous way

```{r, fig.width = 6}
by_species <- group_by(drop_na(penguins), species, sex)
measures <- summarise(by_species,
  count = n(),
  med_bill_length_mm = median(bill_length_mm, na.rm = TRUE),
  med_bill_depth_mm = median(bill_depth_mm, na.rm = TRUE),
  med_flipper_length_mm = median(flipper_length_mm, na.rm = TRUE),
  med_body_mass_g = median(body_mass_g, na.rm = TRUE)
)

ggplot(data = measures, mapping = aes(x = med_body_mass_g, 
                                      y = med_flipper_length_mm)) +
  geom_point(aes(size = count), alpha = 1/3) 
```

### Using the pipe %>%

```{r}
penguins %>% 
  drop_na() %>% 
  group_by(species, sex) %>% 
  summarise(count = n(),
  med_bill_length_mm = median(bill_length_mm, na.rm = TRUE),
  med_bill_depth_mm = median(bill_depth_mm, na.rm = TRUE),
  med_flipper_length_mm = median(flipper_length_mm, na.rm = TRUE),
  med_body_mass_g = median(body_mass_g, na.rm = TRUE)) %>% 
  ggplot(mapping = aes(x = med_body_mass_g, 
                                      y = med_flipper_length_mm)) +
  geom_point(aes(size = count), alpha = 1/3) 
```

```{r, echo = FALSE, eval = FALSE}
# Hidden parts of code - replicated in R4DS, and 
# coded by hand for practice!
flights %>% 
  group_by(dest) %>% 
  summarise(count = n(),
            dist = mean(distance, na.rm = TRUE),
            delay = mean(arr_delay, na.rm = TRUE)) %>% 
  filter(count > 20, dest != "HNL")
```

```{r, echo = FALSE, eval = FALSE}
# Hidden parts of code - replicated in R4DS, and 
# coded by hand for practice!
starwars %>% 
  select(gender, height, mass, species) %>% 
  filter(species == "Human") %>% 
  drop_na() %>% 
  mutate(
    # convert height to meters instead of cm
    height = height / 100,
    BMI = mass / height ^ 2
  ) %>% 
  group_by(gender) %>% 
  summarise(avg_bmi = mean(BMI))
```

```{r, echo = FALSE, eval = FALSE}
# Hidden parts of code - replicated in R4DS, and 
# coded by hand for practice!

not_cancelled <- flights %>% 
  filter(!is.na(dep_delay),
         !is.na(arr_delay))

# na's already removed
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(mean_dep = mean(dep_delay))
```

## Counts

- `n()` which produces a count and,
- `sum(is.na(some_variable))` gives you the NA sum of data.

```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(count = n())

# how many missing data in certain characteristics?
penguins %>% 
  select(species, body_mass_g) %>% 
  group_by(species) %>% 
  summarise(count = sum(is.na(body_mass_g)))

# how many missing data in certain characteristics?
penguins %>% 
  select(species, bill_length_mm) %>% 
  group_by(species) %>% 
  summarise(count = sum(is.na(bill_length_mm)))
```

```{r, echo = FALSE, eval = FALSE}
# Hidden parts of code - replicated in R4DS, and 
# coded by hand for practice!

delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(delay = mean(arr_delay))

ggplot(data = delays, mapping = aes(x = delay)) +
  geom_freqpoly(binwidth = 10)

# The plot shows that there are some plots that average
# more than 5 hours delay!
# But the story is more nuanced. There is a small number with
# high delays

delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(delay = mean(arr_delay, na.rm = TRUE),
            n = n())

ggplot(data = delays, mapping = aes(x = n, y = delay)) +
  geom_point(alpha = 1/10)

# The variation in the delays when there are few flights is much more 
# pronounced.

# we can combine some dplyr and ggplot wrangling
# to see the true variation better.

delays %>% 
  filter(n > 65) %>% 
  ggplot(aes(x = n, y = delay)) +
  geom_point(alpha = 1/10)

# Batting average vs Number of times they bat
batting <- as_tibble(Lahman::Batting)

batters <- batting %>% 
  group_by(playerID) %>% 
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %>% 
  filter(ab > 100) %>% 
  ggplot(mapping = aes(x = ab, y = ba)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

## Useful summary Functions

### Measures of Location (mean, median etc.)

- Median: `median(x) is the value of x where 50% of the variable x
lies above that value, and 50% of the variable x lies below that value.

```{r}
not_cancelled <- flights %>% 
  filter(!is.na(dep_delay),
         !is.na(arr_delay))

not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    # avg_delay
    avg_delay1 = mean(arr_delay),
    # avg positive delay - filter our only positive arrival delay
    avg_delay2 = mean(arr_delay[arr_delay > 0])
  )
```

### Measures of spread (sd, IQR etc.)

- Standard deviation: sd() measures the spread of a variable, the
larger the sd the more dispersed the data.
- Inter Quartile Range: IQR() measures the spread in the middle -
i.e. it measures the spread in the middle 50% of the variable. The measure
is useful if there are outliers. $IQR = Q{3} - Q{1}$.
- Median Absolute Deviation: mad() measures how far each point is from the
median of the variable in absolute terms.
- Need the Mean Absolute Deviation: That can be found in the [DescTools](https://rdrr.io/cran/DescTools/man/MeanAD.html) package.

```{r}
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(dist_sd = sd(distance),
            dist_iqr = IQR(distance),
            dist_mad = mad(distance)) %>% 
  arrange(desc(dist_sd))
```

### Measures of rank - min() etc.

- min(), max(), quantile(x, 0.75)
- quantiles: quantile(x, 0.25) will find the value of x which is larger than 25% of the values, but less than the remaining 75%.

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )
```

### Measures of position - first() etc.

- first() - i.e. x[1]
- nth(x, 2) - i.e. x[2]
- last(x) - i.e. x[length[x]]
- If the position does not exist, you may supply a default.

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = first(dep_time),
    last = last(dep_time)
  )
```

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  # min_rank is like rank but for ties the method is min
  mutate(r = min_rank(desc(dep_time))) %>% 
  filter(r %in% range(r))
```

### Counts

We have used n(), now we also have:

- count(x): raw counts in each category of x
- n_distinct(x): unique values in x

```{r}
# Find distinct number of carriers at each dest
# and sort by highest to lowest
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(num_carrier = n_distinct(carrier)) %>% 
  arrange(desc(num_carrier))

# counts are also useful
not_cancelled %>% 
  count(dest)

# adding sort = TRUE puts the biggest counts at the top
not_cancelled %>% 
  count(dest, sort = TRUE)

# can add weighted counts
not_cancelled %>% 
  count(tailnum, wt = distance)

# sum of logical values gives number of occurrences
# where something is TRUE
# How many flights were early, say before 5AM?
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(n_early = sum(dep_time < 500))

# mean of logical values gives a proportion
# how many flights were delayed more than an hour?
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(hour_prop = mean(arr_delay > 60))
```

### Grouping by Multiple Variables

When you group by multiple variables, each summary peels off one level of the grouping. It makes it easy to progressively roll up a dataset, but it should be used with sums and counts and not with medians etc.

```{r}
daily <- group_by(flights, year, month, day)
# count flights per day
(per_day   <- summarise(daily, flights = n()))
# count flights per month
(per_month <- summarise(per_day, flights = sum(flights)))
# count flights per year
(per_year  <- summarise(per_month, flights = sum(flights)))
```

### Ungrouping

You can remove grouping as well.

```{r}
daily %>% 
  ungroup() %>%             # no longer grouped by date
  summarise(flights = n())  # count all flights
```

### Exercises

1.  Brainstorm at least 5 different ways to assess the typical delay 
    characteristics of a group of flights. Consider the following scenarios:
    
    * A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of 
      the time.
      
    * A flight is always 10 minutes late.

    * A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of 
      the time.
      
    * 99% of the time a flight is on time. 1% of the time it's 2 hours late.
    
    Which is more important: arrival delay or departure delay?
    
    I think arrival delay is more important especially since many people have 
    connecting flights. I would guess it would be more important in typical
    connection airports e.g. Atlanta, Los Angeles, international airports like 
    Dubai, Qatar, Heathrow etc. as it is often an area which travellers 
    pass through.
    
    ```{r}
    # The flights data has local flights within the US
    flights %>% 
      count(carrier, sort = TRUE)
    
    flights %>% 
      count(dest, sort = TRUE)
    
    # Let's have a look at the busiest airports
    # It has changed a bit from our data of 2013
    # https://en.wikipedia.org/wiki/List_of_the_busiest_airports_in_the_United_States
    flights %>% 
      filter(dest %in% c('ATL', 'LAX', 'ORD', 'BOS',
                         'MCO')) %>% 
      count(dest, sort = TRUE)
    
    top5_dests <- flights %>% 
      add_count(dest, sort = TRUE, name = 'count') %>% 
      select(dest, count) %>% 
      count(dest, sort = TRUE) %>% 
      slice_max(n, n = 5)
    
    top_dests <- flights %>% 
      filter(dest %in% c(top5_dests %>% select(dest))$dest)
    
    top_dests %>% 
      pivot_longer(cols = c(arr_delay, dep_delay),
                   names_to = "metric",
                   values_to = "value") %>% 
      ggplot(aes(value, fill = dest)) +
      geom_density(alpha = 0.5) +
      facet_wrap(dest ~ metric, 
                 scales = "free",
                 nrow = 3)
    
    ```
    

1.  Come up with another approach that will give you the same output as 
    `not_cancelled %>% count(dest)` and 
    `not_cancelled %>% count(tailnum, wt = distance)` (without using 
    `count()`).
    
    ```{r}
    
    not_cancelled %>% count(dest)
    
    # Alt:
    not_cancelled %>% 
      group_by(dest) %>% 
      summarise(n = n())
    
    not_cancelled %>% count(tailnum, wt = distance)
    
    # Alt:
    not_cancelled %>% 
      group_by(tailnum) %>% 
      summarise(n = sum(distance))
    
    ```
    

1.  Our definition of cancelled flights (`is.na(dep_delay) | is.na(arr_delay)`
    ) is slightly suboptimal. Why? Which is the most important column?
    
    On first thought I would assume that the dep_delay is most important since if
    it is null I would assume that is an indication of a cancellation.
    
    ```{r}
    
    # Okay let's look at the NAs in each column
    flights %>% 
      select(dep_delay, arr_delay, air_time) %>% 
      summarise_all(~ sum(is.na(.)))
    
    ```
    
    Okay, so the arr_delay count of NAs is larger and is the same as the NULLs
    in air_time. What could be the reason for arr_delay NULLs being larger than
    dep_delay NULLs?
    One could be [crashes](https://en.wikipedia.org/wiki/Category:Aviation_accidents_and_incidents_in_the_United_States_in_2013) 
    but there does not seem to be crashes from flights originating out of NY. 
    The other could be diverted
    [flights](https://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236).
    I therefore think we need to have a definition of what is considered 
    cancelled? If diversions are considered cancelled then the arr_delay being NULL
    is more important, if diversions are not included the dep_delay being NULL
    should be considered. Without talking to an aviation expert I looked at a 
    wikipedia page that seems to suggest that cancellations are that the 
    [airline does not operate the flight __at all__ for a certain reason](https://en.wikipedia.org/wiki/Flight_cancellation_and_delay#:~:text=A%20cancellation%20occurs%20when%20the,all%20for%20a%20certain%20reason.&text=Airlines%20are%20required%20to%20pay,their%20control%2C%20such%20as%20weather.)
    

1.  Look at the number of cancelled flights per day. Is there a pattern?
    Is the proportion of cancelled flights related to the average delay?
    
    ```{r}
    # Keeping to the definition of cancellations being either 
    # true non-flights and diversions
    cancelled <- flights %>% 
      filter(is.na(dep_delay) | is.na(arr_delay))
    
    cancelled <- cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(num_cancelled = n())
    
    avg_delays <- flights %>% 
      group_by(year, month, day) %>% 
      summarise(num_flights_on_day = n(),
                avg_dep_delay = mean(dep_delay[dep_delay > 0], na.rm = TRUE),
                avg_arr_delay = mean(arr_delay[arr_delay > 0], na.rm = TRUE))
    
    # we haven't seen this yet but this joins the two datasets
    # so we can analyse it
    # For now consider inner_join as tagging on columns for avg_delays onto
    # cancelled where the cancelled.year = avg_delays.year, 
    # cancelled.month = avg_delays.month and cancelled.day = avg_delays.day
    cancelled %>% 
      inner_join(avg_delays) %>% 
      # here again we use a function that we have not seen yet
      # we make a date using the {lubridate} from the
      # components of the date - year, month, day
      mutate(date = make_date(year, month, day),
             prop_cancelled = num_cancelled / num_flights_on_day) %>% 
      pivot_longer(cols = c(num_cancelled, prop_cancelled, num_flights_on_day,
                            avg_dep_delay, avg_arr_delay),
                   names_to = "metric",
                   values_to = "value") %>% 
      ggplot(aes(x = date, y = value, fill = metric)) +
      geom_point() +
      labs(title = "Number of delayed flights and the average delay on the day",
           y = "Measure of Metric") +
      facet_wrap(~ metric, scales = "free_y") +
      geom_smooth(se = FALSE)
    
    ```
    If you look at the proportion of cancelled flights it does seem
    as though this increases the average delays experienced.
    

1.  Which carrier has the worst delays? 
    
    ```{r}
    
    flights %>% 
      mutate(avg_delay = mean(dep_delay, na.rm=TRUE)) %>% 
      group_by(carrier) %>% 
      mutate(avg_delay_carrier = mean(dep_delay, na.rm = TRUE)) %>% 
      select(carrier, avg_delay, avg_delay_carrier) %>% 
      distinct() %>% 
      filter(avg_delay_carrier > avg_delay) %>% 
      arrange(-avg_delay_carrier)
    
    flights %>% 
      mutate(avg_arr_delay = mean(arr_delay, na.rm=TRUE)) %>% 
      group_by(carrier) %>% 
      mutate(avg_arr_delay_carrier = mean(arr_delay, na.rm = TRUE)) %>% 
      select(carrier, avg_arr_delay, avg_arr_delay_carrier) %>% 
      distinct() %>% 
      filter(avg_arr_delay_carrier > avg_arr_delay) %>% 
      arrange(-avg_arr_delay_carrier)
    
    ```
    Challenge: can you disentangle the
    effects of bad airports vs. bad carriers? Why/why not? (Hint: think about
    `flights %>% group_by(carrier, dest) %>% summarise(n())`)
    
    ```{r}
    flights %>% 
      group_by(carrier, dest) %>% 
      summarise(n())
    
    
    # 3 origins
    flights %>% 
      count(origin, sort = TRUE)
    
    # many destinations
    flights %>% 
      count(dest, sort = TRUE)
    
    # how many carriers
    flights %>% 
      count(carrier, sort = TRUE)
    
    flights %>% 
      count(carrier, dest, sort = TRUE) %>% 
      slice_max(n = 25, order_by = n) %>% 
      gt()
    
    # how many combos of carrier and dest?
    (dests <- flights %>% 
      distinct(carrier, dest))
    # notice every carrier does not fly to every destination
    
    across_all <- flights %>% 
      mutate(avg_arr_delay = mean(arr_delay[arr_delay>0], 
                                  na.rm = TRUE),
             med_arr_delay = median(arr_delay[arr_delay>0], 
                                    na.rm = TRUE)) %>% 
      group_by(carrier) %>% 
      mutate(avg_carrier_arr_delay = mean(arr_delay[arr_delay>0], 
                                          na.rm = TRUE),
             med_carrier_arr_delay = median(arr_delay[arr_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      group_by(dest) %>% 
      mutate(avg_dest_arr_delay = mean(arr_delay[arr_delay>0], 
                                          na.rm = TRUE),
             med_dest_arr_delay = median(arr_delay[arr_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      group_by(carrier, dest) %>% 
      mutate(avg_cd_arr_delay = mean(arr_delay[arr_delay>0], 
                                          na.rm = TRUE),
             med_cd_arr_delay = median(arr_delay[arr_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      select(carrier, dest, avg_arr_delay, avg_carrier_arr_delay,
             avg_dest_arr_delay, avg_cd_arr_delay,
             med_arr_delay, med_carrier_arr_delay,
             med_dest_arr_delay, med_cd_arr_delay) %>% 
      arrange(desc(avg_cd_arr_delay), -med_cd_arr_delay) %>% 
      distinct() 
    
    across_all%>% 
      head(25) %>% 
      gt()
    
    
    across_all %>% 
      count(carrier, sort = TRUE)
    
    across_all %>% 
      count(dest, sort=TRUE)
    
    across_all_dep <- flights %>% 
      mutate(avg_dep_delay = mean(dep_delay[dep_delay>0], 
                                  na.rm = TRUE),
             med_dep_delay = median(dep_delay[dep_delay>0], 
                                    na.rm = TRUE)) %>% 
      group_by(carrier) %>% 
      mutate(avg_carrier_dep_delay = mean(dep_delay[dep_delay>0], 
                                          na.rm = TRUE),
             med_carrier_dep_delay = median(dep_delay[dep_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      group_by(origin) %>% 
      mutate(avg_dest_dep_delay = mean(dep_delay[dep_delay>0], 
                                          na.rm = TRUE),
             med_dest_dep_delay = median(dep_delay[dep_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      group_by(carrier, origin) %>% 
      mutate(avg_cd_dep_delay = mean(dep_delay[dep_delay>0], 
                                          na.rm = TRUE),
             med_cd_dep_delay = median(dep_delay[dep_delay>0], 
                                            na.rm = TRUE)) %>% 
      ungroup() %>% 
      select(carrier, origin, avg_dep_delay, avg_carrier_dep_delay,
             avg_dest_dep_delay, avg_cd_dep_delay,
             med_dep_delay, med_carrier_dep_delay,
             med_dest_dep_delay, med_cd_dep_delay) %>% 
      arrange(desc(avg_cd_dep_delay), -med_cd_dep_delay) %>% 
      distinct()  
    
    across_all_dep %>% 
      head(25) %>% 
      gt()
    
    across_all_dep %>% 
      count(carrier, sort = TRUE)
    
    across_all_dep %>% 
      count(origin, sort=TRUE)
    ```
    <br>
    
    There does seem more of a delay based on carrier than on airport
    but I can't put much faith in this since I did not do a thorough
    investigation - for example 
    some carriers had more flights, some destinations are busier.
    We should therefore look at proportions of all flights maybe, and
    there are other specifics that I as an aviation newbie have not
    even thought of.
    Here I had a rough look at the 
    average and median delay by carrier, destination and the combination
    of carrier and destination. Sorting by the largest delays in the
    combination average and median gets us to seeming a lot of delays
    from particular carriers like EV, but I wouldn't put much faith
    in this until a proper investigation is done.
    
1.  For each plane, count the number of flights before the first delay 
    of greater than 1 hour.
    
    ```{r}
    # Dep delay 
    flights %>% 
      # group by plane
      group_by(tailnum) %>% 
      # arrange by flight date
      arrange(year, month, day) %>% 
      # assign a row number to each
      mutate(row_number = row_number()) %>% 
      # ungroup to clear the grouping
      ungroup() %>% 
      # okay get only the delays beyond 60 min
      filter(dep_delay > 60) %>% 
      # group again by plane
      group_by(tailnum) %>% 
      # the number of flights before the first delay will be the
      # row number - 1
      mutate(num_flights = first(row_number) - 1) %>% 
      select(tailnum, num_flights) %>% 
      distinct() %>% 
      arrange(desc(num_flights)) %>% 
      DT::datatable()
    
    # Let's check one of them to ensure we're on the right track
    flights %>% 
       filter(tailnum == 'N712TW') %>% 
       select(year, month, day, tailnum, dep_delay) %>% 
       arrange(year, month, day)  %>% 
       DT::datatable()
    
    # Arrival delays
    flights %>% 
      # group by plane
      group_by(tailnum) %>% 
      # arrange by flight date
      arrange(year, month, day) %>% 
      # assign a row number to each
      mutate(row_number = row_number()) %>% 
      # ungroup to clear the grouping
      ungroup() %>% 
      # okay get only the delays beyond 60 min
      filter(arr_delay > 60) %>% 
      # group again by plane
      group_by(tailnum) %>% 
      # the number of flights before the first delay will be the
      # row number - 1
      mutate(num_flights = first(row_number) - 1) %>% 
      select(tailnum, num_flights) %>% 
      distinct() %>% 
      filter(num_flights > 25) %>% 
      arrange(num_flights, tailnum) %>% 
      DT::datatable()
    
    # Let's check one of them to ensure we're on the right track
    # It's on Page 16 in the DT above, entry 152
    flights %>% 
       filter(tailnum == 'N597UA') %>% 
       select(year, month, day, tailnum, arr_delay) %>% 
       arrange(year, month, day)  %>% 
       DT::datatable()
    ```
    
1.  What does the `sort` argument to `count()` do. When might you use it?

    The `sort = TRUE` in __count()__ allows us to see the items with the
    highest counts up at the top - it sorts the count in descending order.























